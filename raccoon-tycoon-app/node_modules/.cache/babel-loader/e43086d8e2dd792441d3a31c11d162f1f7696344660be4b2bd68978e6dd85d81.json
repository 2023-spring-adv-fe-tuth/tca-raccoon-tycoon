{"ast":null,"code":"export const convertToNative = (data, options) => {\n  for (const [key, value] of Object.entries(data)) {\n    if (value !== undefined) {\n      switch (key) {\n        case \"NULL\":\n          return null;\n        case \"BOOL\":\n          return Boolean(value);\n        case \"N\":\n          return convertNumber(value, options);\n        case \"B\":\n          return convertBinary(value);\n        case \"S\":\n          return convertString(value);\n        case \"L\":\n          return convertList(value, options);\n        case \"M\":\n          return convertMap(value, options);\n        case \"NS\":\n          return new Set(value.map(item => convertNumber(item, options)));\n        case \"BS\":\n          return new Set(value.map(convertBinary));\n        case \"SS\":\n          return new Set(value.map(convertString));\n        default:\n          throw new Error(`Unsupported type passed: ${key}`);\n      }\n    }\n  }\n  throw new Error(`No value defined: ${JSON.stringify(data)}`);\n};\nconst convertNumber = (numString, options) => {\n  if (options?.wrapNumbers) {\n    return {\n      value: numString\n    };\n  }\n  const num = Number(numString);\n  const infinityValues = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];\n  if ((num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER) && !infinityValues.includes(num)) {\n    if (typeof BigInt === \"function\") {\n      try {\n        return BigInt(numString);\n      } catch (error) {\n        throw new Error(`${numString} can't be converted to BigInt. Set options.wrapNumbers to get string value.`);\n      }\n    } else {\n      throw new Error(`${numString} is outside SAFE_INTEGER bounds. Set options.wrapNumbers to get string value.`);\n    }\n  }\n  return num;\n};\nconst convertString = stringValue => stringValue;\nconst convertBinary = binaryValue => binaryValue;\nconst convertList = (list, options) => list.map(item => convertToNative(item, options));\nconst convertMap = (map, options) => Object.entries(map).reduce((acc, _ref) => {\n  let [key, value] = _ref;\n  return acc[key] = convertToNative(value, options), acc;\n}, {});","map":{"version":3,"names":["convertToNative","data","options","key","value","Object","entries","undefined","Boolean","convertNumber","convertBinary","convertString","convertList","convertMap","Set","map","item","Error","JSON","stringify","numString","wrapNumbers","num","Number","infinityValues","POSITIVE_INFINITY","NEGATIVE_INFINITY","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","includes","BigInt","error","stringValue","binaryValue","list","reduce","acc","_ref"],"sources":["C:/Users/steph/OneDrive/Documents/GitHub/personal/tca-raccoon-tycoon/raccoon-tycoon-app/node_modules/@aws-sdk/util-dynamodb/dist-es/convertToNative.js"],"sourcesContent":["export const convertToNative = (data, options) => {\n    for (const [key, value] of Object.entries(data)) {\n        if (value !== undefined) {\n            switch (key) {\n                case \"NULL\":\n                    return null;\n                case \"BOOL\":\n                    return Boolean(value);\n                case \"N\":\n                    return convertNumber(value, options);\n                case \"B\":\n                    return convertBinary(value);\n                case \"S\":\n                    return convertString(value);\n                case \"L\":\n                    return convertList(value, options);\n                case \"M\":\n                    return convertMap(value, options);\n                case \"NS\":\n                    return new Set(value.map((item) => convertNumber(item, options)));\n                case \"BS\":\n                    return new Set(value.map(convertBinary));\n                case \"SS\":\n                    return new Set(value.map(convertString));\n                default:\n                    throw new Error(`Unsupported type passed: ${key}`);\n            }\n        }\n    }\n    throw new Error(`No value defined: ${JSON.stringify(data)}`);\n};\nconst convertNumber = (numString, options) => {\n    if (options?.wrapNumbers) {\n        return { value: numString };\n    }\n    const num = Number(numString);\n    const infinityValues = [Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY];\n    if ((num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER) && !infinityValues.includes(num)) {\n        if (typeof BigInt === \"function\") {\n            try {\n                return BigInt(numString);\n            }\n            catch (error) {\n                throw new Error(`${numString} can't be converted to BigInt. Set options.wrapNumbers to get string value.`);\n            }\n        }\n        else {\n            throw new Error(`${numString} is outside SAFE_INTEGER bounds. Set options.wrapNumbers to get string value.`);\n        }\n    }\n    return num;\n};\nconst convertString = (stringValue) => stringValue;\nconst convertBinary = (binaryValue) => binaryValue;\nconst convertList = (list, options) => list.map((item) => convertToNative(item, options));\nconst convertMap = (map, options) => Object.entries(map).reduce((acc, [key, value]) => ((acc[key] = convertToNative(value, options)), acc), {});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}