{"ast":null,"code":"export const convertToAttr = (data, options) => {\n  if (data === undefined) {\n    throw new Error(`Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.`);\n  } else if (data === null && typeof data === \"object\") {\n    return convertToNullAttr();\n  } else if (Array.isArray(data)) {\n    return convertToListAttr(data, options);\n  } else if (data?.constructor?.name === \"Set\") {\n    return convertToSetAttr(data, options);\n  } else if (data?.constructor?.name === \"Map\") {\n    return convertToMapAttrFromIterable(data, options);\n  } else if (data?.constructor?.name === \"Object\" || !data.constructor && typeof data === \"object\") {\n    return convertToMapAttrFromEnumerableProps(data, options);\n  } else if (isBinary(data)) {\n    if (data.length === 0 && options?.convertEmptyValues) {\n      return convertToNullAttr();\n    }\n    return convertToBinaryAttr(data);\n  } else if (typeof data === \"boolean\" || data?.constructor?.name === \"Boolean\") {\n    return {\n      BOOL: data.valueOf()\n    };\n  } else if (typeof data === \"number\" || data?.constructor?.name === \"Number\") {\n    return convertToNumberAttr(data);\n  } else if (typeof data === \"bigint\") {\n    return convertToBigIntAttr(data);\n  } else if (typeof data === \"string\" || data?.constructor?.name === \"String\") {\n    if (data.length === 0 && options?.convertEmptyValues) {\n      return convertToNullAttr();\n    }\n    return convertToStringAttr(data);\n  } else if (options?.convertClassInstanceToMap && typeof data === \"object\") {\n    return convertToMapAttrFromEnumerableProps(data, options);\n  }\n  throw new Error(`Unsupported type passed: ${data}. Pass options.convertClassInstanceToMap=true to marshall typeof object as map attribute.`);\n};\nconst convertToListAttr = (data, options) => ({\n  L: data.filter(item => !options?.removeUndefinedValues || options?.removeUndefinedValues && item !== undefined).map(item => convertToAttr(item, options))\n});\nconst convertToSetAttr = (set, options) => {\n  const setToOperate = options?.removeUndefinedValues ? new Set([...set].filter(value => value !== undefined)) : set;\n  if (!options?.removeUndefinedValues && setToOperate.has(undefined)) {\n    throw new Error(`Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.`);\n  }\n  if (setToOperate.size === 0) {\n    if (options?.convertEmptyValues) {\n      return convertToNullAttr();\n    }\n    throw new Error(`Pass a non-empty set, or options.convertEmptyValues=true.`);\n  }\n  const item = setToOperate.values().next().value;\n  if (typeof item === \"number\") {\n    return {\n      NS: Array.from(setToOperate).map(convertToNumberAttr).map(item => item.N)\n    };\n  } else if (typeof item === \"bigint\") {\n    return {\n      NS: Array.from(setToOperate).map(convertToBigIntAttr).map(item => item.N)\n    };\n  } else if (typeof item === \"string\") {\n    return {\n      SS: Array.from(setToOperate).map(convertToStringAttr).map(item => item.S)\n    };\n  } else if (isBinary(item)) {\n    return {\n      BS: Array.from(setToOperate).map(convertToBinaryAttr).map(item => item.B)\n    };\n  } else {\n    throw new Error(`Only Number Set (NS), Binary Set (BS) or String Set (SS) are allowed.`);\n  }\n};\nconst convertToMapAttrFromIterable = (data, options) => ({\n  M: (data => {\n    const map = {};\n    for (const [key, value] of data) {\n      if (typeof value !== \"function\" && (value !== undefined || !options?.removeUndefinedValues)) {\n        map[key] = convertToAttr(value, options);\n      }\n    }\n    return map;\n  })(data)\n});\nconst convertToMapAttrFromEnumerableProps = (data, options) => ({\n  M: (data => {\n    const map = {};\n    for (const key in data) {\n      const value = data[key];\n      if (typeof value !== \"function\" && (value !== undefined || !options?.removeUndefinedValues)) {\n        map[key] = convertToAttr(value, options);\n      }\n    }\n    return map;\n  })(data)\n});\nconst convertToNullAttr = () => ({\n  NULL: true\n});\nconst convertToBinaryAttr = data => ({\n  B: data\n});\nconst convertToStringAttr = data => ({\n  S: data.toString()\n});\nconst convertToBigIntAttr = data => ({\n  N: data.toString()\n});\nconst validateBigIntAndThrow = errorPrefix => {\n  throw new Error(`${errorPrefix} ${typeof BigInt === \"function\" ? \"Use BigInt.\" : \"Pass string value instead.\"} `);\n};\nconst convertToNumberAttr = num => {\n  if ([Number.NaN, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY].map(val => val.toString()).includes(num.toString())) {\n    throw new Error(`Special numeric value ${num.toString()} is not allowed`);\n  } else if (num > Number.MAX_SAFE_INTEGER) {\n    validateBigIntAndThrow(`Number ${num.toString()} is greater than Number.MAX_SAFE_INTEGER.`);\n  } else if (num < Number.MIN_SAFE_INTEGER) {\n    validateBigIntAndThrow(`Number ${num.toString()} is lesser than Number.MIN_SAFE_INTEGER.`);\n  }\n  return {\n    N: num.toString()\n  };\n};\nconst isBinary = data => {\n  const binaryTypes = [\"ArrayBuffer\", \"Blob\", \"Buffer\", \"DataView\", \"File\", \"Int8Array\", \"Uint8Array\", \"Uint8ClampedArray\", \"Int16Array\", \"Uint16Array\", \"Int32Array\", \"Uint32Array\", \"Float32Array\", \"Float64Array\", \"BigInt64Array\", \"BigUint64Array\"];\n  if (data?.constructor) {\n    return binaryTypes.includes(data.constructor.name);\n  }\n  return false;\n};","map":{"version":3,"names":["convertToAttr","data","options","undefined","Error","convertToNullAttr","Array","isArray","convertToListAttr","constructor","name","convertToSetAttr","convertToMapAttrFromIterable","convertToMapAttrFromEnumerableProps","isBinary","length","convertEmptyValues","convertToBinaryAttr","BOOL","valueOf","convertToNumberAttr","convertToBigIntAttr","convertToStringAttr","convertClassInstanceToMap","L","filter","item","removeUndefinedValues","map","set","setToOperate","Set","value","has","size","values","next","NS","from","N","SS","S","BS","B","M","key","NULL","toString","validateBigIntAndThrow","errorPrefix","BigInt","num","Number","NaN","POSITIVE_INFINITY","NEGATIVE_INFINITY","val","includes","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","binaryTypes"],"sources":["C:/Users/steph/OneDrive/Documents/GitHub/personal/tca-raccoon-tycoon/raccoon-tycoon-app/node_modules/@aws-sdk/util-dynamodb/dist-es/convertToAttr.js"],"sourcesContent":["export const convertToAttr = (data, options) => {\n    if (data === undefined) {\n        throw new Error(`Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.`);\n    }\n    else if (data === null && typeof data === \"object\") {\n        return convertToNullAttr();\n    }\n    else if (Array.isArray(data)) {\n        return convertToListAttr(data, options);\n    }\n    else if (data?.constructor?.name === \"Set\") {\n        return convertToSetAttr(data, options);\n    }\n    else if (data?.constructor?.name === \"Map\") {\n        return convertToMapAttrFromIterable(data, options);\n    }\n    else if (data?.constructor?.name === \"Object\" ||\n        (!data.constructor && typeof data === \"object\")) {\n        return convertToMapAttrFromEnumerableProps(data, options);\n    }\n    else if (isBinary(data)) {\n        if (data.length === 0 && options?.convertEmptyValues) {\n            return convertToNullAttr();\n        }\n        return convertToBinaryAttr(data);\n    }\n    else if (typeof data === \"boolean\" || data?.constructor?.name === \"Boolean\") {\n        return { BOOL: data.valueOf() };\n    }\n    else if (typeof data === \"number\" || data?.constructor?.name === \"Number\") {\n        return convertToNumberAttr(data);\n    }\n    else if (typeof data === \"bigint\") {\n        return convertToBigIntAttr(data);\n    }\n    else if (typeof data === \"string\" || data?.constructor?.name === \"String\") {\n        if (data.length === 0 && options?.convertEmptyValues) {\n            return convertToNullAttr();\n        }\n        return convertToStringAttr(data);\n    }\n    else if (options?.convertClassInstanceToMap && typeof data === \"object\") {\n        return convertToMapAttrFromEnumerableProps(data, options);\n    }\n    throw new Error(`Unsupported type passed: ${data}. Pass options.convertClassInstanceToMap=true to marshall typeof object as map attribute.`);\n};\nconst convertToListAttr = (data, options) => ({\n    L: data\n        .filter((item) => !options?.removeUndefinedValues || (options?.removeUndefinedValues && item !== undefined))\n        .map((item) => convertToAttr(item, options)),\n});\nconst convertToSetAttr = (set, options) => {\n    const setToOperate = options?.removeUndefinedValues ? new Set([...set].filter((value) => value !== undefined)) : set;\n    if (!options?.removeUndefinedValues && setToOperate.has(undefined)) {\n        throw new Error(`Pass options.removeUndefinedValues=true to remove undefined values from map/array/set.`);\n    }\n    if (setToOperate.size === 0) {\n        if (options?.convertEmptyValues) {\n            return convertToNullAttr();\n        }\n        throw new Error(`Pass a non-empty set, or options.convertEmptyValues=true.`);\n    }\n    const item = setToOperate.values().next().value;\n    if (typeof item === \"number\") {\n        return {\n            NS: Array.from(setToOperate)\n                .map(convertToNumberAttr)\n                .map((item) => item.N),\n        };\n    }\n    else if (typeof item === \"bigint\") {\n        return {\n            NS: Array.from(setToOperate)\n                .map(convertToBigIntAttr)\n                .map((item) => item.N),\n        };\n    }\n    else if (typeof item === \"string\") {\n        return {\n            SS: Array.from(setToOperate)\n                .map(convertToStringAttr)\n                .map((item) => item.S),\n        };\n    }\n    else if (isBinary(item)) {\n        return {\n            BS: Array.from(setToOperate)\n                .map(convertToBinaryAttr)\n                .map((item) => item.B),\n        };\n    }\n    else {\n        throw new Error(`Only Number Set (NS), Binary Set (BS) or String Set (SS) are allowed.`);\n    }\n};\nconst convertToMapAttrFromIterable = (data, options) => ({\n    M: ((data) => {\n        const map = {};\n        for (const [key, value] of data) {\n            if (typeof value !== \"function\" && (value !== undefined || !options?.removeUndefinedValues)) {\n                map[key] = convertToAttr(value, options);\n            }\n        }\n        return map;\n    })(data),\n});\nconst convertToMapAttrFromEnumerableProps = (data, options) => ({\n    M: ((data) => {\n        const map = {};\n        for (const key in data) {\n            const value = data[key];\n            if (typeof value !== \"function\" && (value !== undefined || !options?.removeUndefinedValues)) {\n                map[key] = convertToAttr(value, options);\n            }\n        }\n        return map;\n    })(data),\n});\nconst convertToNullAttr = () => ({ NULL: true });\nconst convertToBinaryAttr = (data) => ({ B: data });\nconst convertToStringAttr = (data) => ({ S: data.toString() });\nconst convertToBigIntAttr = (data) => ({ N: data.toString() });\nconst validateBigIntAndThrow = (errorPrefix) => {\n    throw new Error(`${errorPrefix} ${typeof BigInt === \"function\" ? \"Use BigInt.\" : \"Pass string value instead.\"} `);\n};\nconst convertToNumberAttr = (num) => {\n    if ([Number.NaN, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY]\n        .map((val) => val.toString())\n        .includes(num.toString())) {\n        throw new Error(`Special numeric value ${num.toString()} is not allowed`);\n    }\n    else if (num > Number.MAX_SAFE_INTEGER) {\n        validateBigIntAndThrow(`Number ${num.toString()} is greater than Number.MAX_SAFE_INTEGER.`);\n    }\n    else if (num < Number.MIN_SAFE_INTEGER) {\n        validateBigIntAndThrow(`Number ${num.toString()} is lesser than Number.MIN_SAFE_INTEGER.`);\n    }\n    return { N: num.toString() };\n};\nconst isBinary = (data) => {\n    const binaryTypes = [\n        \"ArrayBuffer\",\n        \"Blob\",\n        \"Buffer\",\n        \"DataView\",\n        \"File\",\n        \"Int8Array\",\n        \"Uint8Array\",\n        \"Uint8ClampedArray\",\n        \"Int16Array\",\n        \"Uint16Array\",\n        \"Int32Array\",\n        \"Uint32Array\",\n        \"Float32Array\",\n        \"Float64Array\",\n        \"BigInt64Array\",\n        \"BigUint64Array\",\n    ];\n    if (data?.constructor) {\n        return binaryTypes.includes(data.constructor.name);\n    }\n    return false;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}