{"ast":null,"code":"//\n// Interfaces and function types...\n//\n\n;\n;\n//\n// Default function implementations...\n//\nexport const getPreviousPlayers = grs => {\n  // const allPreviousPlayers = grs.map(x => x.players);\n  const allPreviousPlayers = grs.flatMap(x => x.players);\n  return [...new Set(allPreviousPlayers)].sort();\n};\nexport const calculateLeaderboard = results => {\n  const gameResultsGroupedByPlayer = getPreviousPlayers(results).reduce((acc, x) => acc.set(x, results.filter(y => y.players.includes(x))), new Map());\n  return [...gameResultsGroupedByPlayer]\n\n  // First object with names game counts and wins...\n  .map(x => ({\n    name: x[0],\n    totalGames: x[1].length,\n    wins: x[1].filter(y => y.winner === x[0]).length\n  }))\n\n  /// Now use wins and total games to get avg and losses\n  .map(x => ({\n    name: x.name,\n    wins: x.wins,\n    losses: x.totalGames - x.wins,\n    avg: x.wins / x.totalGames\n  }))\n\n  // Sort order, with tie breaks that include number of games played\n  .sort((a, b) => a.avg * 1000 + a.wins + a.losses > b.avg * 1000 + b.wins + b.losses ? -1 : 1)\n\n  // Turn the avg into a 3 digit string.\n  .map(x => ({\n    ...x,\n    avg: x.avg.toFixed(3)\n  }));\n};\nexport const getGameDuration = result => new Date(result.end).getTime() - new Date(result.start).getTime();\nexport const getShortestGameDuration = results => Math.min(...results.map(x => getGameDuration(x)));\nexport const getLongestGameDuration = results => Math.max(...results.map(x => getGameDuration(x)));\nexport const getAverageGameDuration = results => {\n  const sum = results.reduce((acc, x) => acc + getGameDuration(x), 0);\n  return results.length > 0 ? sum / results.length : 0;\n  2;\n};\nexport const getAverageGameDurationByPlayerCount = results => {\n  const grouped = results.reduce((acc, x) => {\n    var _acc$get;\n    return acc.set(x.players.length, [...((_acc$get = acc.get(x.players.length)) !== null && _acc$get !== void 0 ? _acc$get : []), x]);\n  }, new Map());\n  return [...grouped].map(x => ({\n    playerCount: x[0],\n    avgGameDuration: getAverageGameDuration(x[1])\n  })).sort((a, b) => a.playerCount < b.playerCount ? -1 : 1);\n};","map":{"version":3,"names":["getPreviousPlayers","grs","allPreviousPlayers","flatMap","x","players","Set","sort","calculateLeaderboard","results","gameResultsGroupedByPlayer","reduce","acc","set","filter","y","includes","Map","map","name","totalGames","length","wins","winner","losses","avg","a","b","toFixed","getGameDuration","result","Date","end","getTime","start","getShortestGameDuration","Math","min","getLongestGameDuration","max","getAverageGameDuration","sum","getAverageGameDurationByPlayerCount","grouped","_acc$get","get","playerCount","avgGameDuration"],"sources":["C:/Users/steph/OneDrive/Documents/GitHub/personal/tca-raccoon-tycoon/raccoon-tycoon-app/src/front-end-model.ts"],"sourcesContent":["//\r\n// Interfaces and function types...\r\n//\r\nexport interface GameResult {\r\n    winner: string;\r\n    players: string[];\r\n\r\n    start: string;\r\n    end: string;\r\n};\r\n\r\nexport interface LeaderboardPlayer {\r\n    name: string;\r\n    wins: number;\r\n    losses: number;\r\n    avg: string;\r\n};\r\n\r\nexport type GetPreviousPlayersFunc = (results: GameResult[]) => string[];\r\nexport type CalculateLeaderboardFunc = (results: GameResult[]) => LeaderboardPlayer[];\r\n\r\n\r\n//\r\n// Default function implementations...\r\n//\r\nexport const getPreviousPlayers: GetPreviousPlayersFunc = (grs) => {\r\n    \r\n    // const allPreviousPlayers = grs.map(x => x.players);\r\n    const allPreviousPlayers = grs.flatMap(x => x.players);\r\n    \r\n    return [\r\n        ...new Set(allPreviousPlayers)\r\n    ].sort();\r\n};\r\n\r\nexport const calculateLeaderboard: CalculateLeaderboardFunc = (results) => {\r\n\r\n    const gameResultsGroupedByPlayer = getPreviousPlayers(results).reduce(\r\n        (acc, x) => acc.set(\r\n            x\r\n            , results.filter(y => y.players.includes(x))\r\n        )\r\n        , new Map<string, GameResult[]>() \r\n    );\r\n\r\n    return [...gameResultsGroupedByPlayer]\r\n\r\n        // First object with names game counts and wins...\r\n        .map(x => ({\r\n            name: x[0]\r\n            , totalGames: x[1].length\r\n            , wins: x[1].filter(y => y.winner === x[0]).length\r\n        }))\r\n\r\n        /// Now use wins and total games to get avg and losses\r\n        .map(x => ({\r\n            name: x.name\r\n            , wins: x.wins \r\n            , losses: x.totalGames - x.wins\r\n            , avg: x.wins / x.totalGames\r\n        }))\r\n\r\n        // Sort order, with tie breaks that include number of games played\r\n        .sort(\r\n            (a, b) => (a.avg * 1000 + a.wins + a.losses) > (b.avg * 1000 + b.wins + b.losses) ? -1 : 1\r\n        )\r\n\r\n        // Turn the avg into a 3 digit string.\r\n        .map(x => ({\r\n            ...x\r\n            , avg: x.avg.toFixed(3)\r\n        }))\r\n    ;\r\n};\r\n\r\nexport const getGameDuration = \r\n    (result: GameResult) => \r\n        new Date(result.end).getTime() - new Date(result.start).getTime()\r\n;\r\n\r\nexport const getShortestGameDuration = (results: GameResult[]) => Math.min(\r\n    ...results.map(x => getGameDuration(x))\r\n);\r\n\r\nexport const getLongestGameDuration = (results: GameResult[]) => Math.max(\r\n    ...results.map(x => getGameDuration(x))\r\n);\r\n\r\nexport const getAverageGameDuration = (results: GameResult[]) => {\r\n    const sum = results.reduce(\r\n        (acc, x) => acc + getGameDuration(x)\r\n        , 0\r\n    );\r\n\r\n    return results.length > 0\r\n        ? sum / results.length\r\n        : 0\r\n    ;2\r\n};\r\n\r\nexport const getAverageGameDurationByPlayerCount = (results: GameResult[]) => {\r\n\r\n    const grouped = results.reduce(\r\n        (acc, x) => acc.set(\r\n            x.players.length\r\n            , [\r\n                ...(acc.get(x.players.length) ?? [])\r\n                , x\r\n            ]\r\n        )\r\n        , new Map<number, GameResult[]>()\r\n    );\r\n\r\n    return [...grouped]\r\n        .map(x => ({\r\n            playerCount: x[0]\r\n            , avgGameDuration: getAverageGameDuration(x[1])\r\n        }))\r\n        .sort(\r\n            (a, b) => a.playerCount < b.playerCount ? -1 : 1\r\n        )\r\n    ;\r\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}